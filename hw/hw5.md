# HW5

PB20111689 蓝俊玮

## 9.S1

> 试将 Cannon 分块算法 9.5 改为共享存储 PRAM-EREW 模型上的算法，并分析其时间复杂度

因为 Cannon 算法计算时，每个块矩阵是只在一处的，也就是说每个存储单元只有一个处理器去读取它，因此在共享存储体系结构下，本质上是可以看作 PRAM-EREW 模型的。则修改后的算法为：

```python
for all P[i][j] par-do:
	C[i][j] = 0
    for k = 0 to sqrt(p) - 1 do:
        C[i][j] = C[i][j] + A[i][(i + j + k) % sqrt(p)] * B[(i + j + k) % sqrt(p)][j]
```

计算出来的时间复杂度为：
$$
O(\sqrt{p}\times(\frac{n}{\sqrt{p}})^3)=O(\frac{n^3}{p})
$$

## 9.9

对于每个进程 $P_{i,j}$ 来说，它都有 $n-1$ 次迭代步，那么对于每个进程 $P_{i,j}$ 来说，它在每步迭代的过程中，都需要从 $a_{i,k}$ 和 $b_{k,j}$ 中获取数据，即获取与进程同行和同列的数据。则读取计算数据需要的时间为 $2\times t_a$，同时发现它这个操作中还要读取 $c_{i,j}$（这是一步很没有必要的操作），其所需读取时间为 $t_a$，接着计算乘加操作的时间需要 $t_c$，最后将计算结果写入 $c_{i,j}$（这也是很没有必要的重复访存操作），也需要时间 $t_a$。因此在一步迭代过程中，包括读写计算的时间需要 $4t_a+t_c$，那么所有迭代过程之和就是 $n(4t_a+t_c)$。

同时还有赋初值操作 $c_{i,j}=0$，这一步只需要 $t_a$ 时间。

因此该算法的并行运行时间为 $t_a+n(4t_a+t_c)$。
